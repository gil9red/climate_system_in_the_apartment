
//-------------------------------------------------<                   axlib v1.1                    >----------------------------------------------------
//-------------------------------------------------<       Библиотека для работы с шиной 1wire       >----------------------------------------------------
//-------------------------------------------------<    Кузнецов Алексей 2015 http://www.avrki.ru    >----------------------------------------------------

#ifndef W_H_
#define W_H_

#if !defined(MAIN_INIT_H_)
#error "You must included (#include \"main_init.h\") befor use (#include <axlib/1w.h>)."
#endif

//-------------------------------------------------------------------------
//						Объявление служебных псевдонимов
//-------------------------------------------------------------------------

#define A	0
#define B	1
#define C	2
#define D	3

#ifdef	PORTA
	#if PORT_W == A
	#define PORT PORTA
	#define PIN PINA
	#define DDR DDRA
	#endif
#endif

#ifdef	PORTB
	#if PORT_W == B
	#define PORT PORTB
	#define PIN PINB
	#define DDR DDRB
	#endif
#endif

#ifdef	PORTC
	#if PORT_W == C
	#define PORT PORTC
	#define PIN PINC
	#define DDR DDRC
	#endif
#endif

#ifdef	PORTD
	#if PORT_W == D
	#define PORT PORTD
	#define PIN PIND
	#define DDR DDRD
	#endif
#endif


#define OWIRE_0 DDR |= (1<<PIN_W)
#define OWIRE_1 DDR &= ~(1<<PIN_W)	

//-------------------------------------------------------------------------
//							Подключаемые библиотеки
//-------------------------------------------------------------------------

#include <avr/interrupt.h>
#include <util/delay.h>
#include <axlib/type_var.h>

//-------------------------------------------------------------------------
//							Объявление функций
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//	Функция инициализации 1ware.
//	Возвращает 1 если присутствует устройство на шине, иначе 0
//
//-------------------------------------------------------------------------

BYTE owire_init()					
{
	cli();									
	BYTE i, j;						
	OWIRE_0;								
	_delay_us(480);							
	OWIRE_1;								
	_delay_us(2);							
	
	for (i=0; i<100; i++)					
	{
		if (!(PIN & (1<<PIN_W)))			
		{
			for(j=1;j!=0;j++) // ждём, поднимет ли кто-нибудь уровень в течении 255 мкс
				{
				if(PIN & (1<<PIN_W)) break; //если поднял, всё ок.
				_delay_us(1);
				}
			sei();							
			if(j)return 1; //инициализация успешна
				else return 0;	// если уровень так и не подняли, то опустило его не устройство.
		}
		_delay_us(1);						
	}
	sei();									
	return 0;								
}

//-------------------------------------------------------------------------
//	Функция передачи байта в шину 1ware.
//
//	Принимает аргументы:
//
//		BYTE b - Байт который необходимо отправить по шине
//-------------------------------------------------------------------------

void owire_write(BYTE b)			
{
	cli();									
	BYTE temp, i;					
	for(i=0; i<8; i++)						
	{
		temp=(b&0x01);						
		if(temp)							
		{
			OWIRE_0;						
			_delay_us(6);					
			OWIRE_1;					
			_delay_us(64);					
		}
		else								
		{
			OWIRE_0;						
			_delay_us(60);					
			OWIRE_1;						
			_delay_us(10);					
		}
		b>>=1;								
	}
	sei();									
}

//-------------------------------------------------------------------------
//	Функция чтения бита из шины.
//	Возвращает текущее значение бита
//
//-------------------------------------------------------------------------

BYTE owire_read_bit()				
{
	cli();									
	BYTE bit;						
	OWIRE_0;								
	_delay_us(2);							
	OWIRE_1;								
	_delay_us(5);							
	bit = PIN & (1<<PIN_W);					
	_delay_us(80);							
	sei();									
	return bit;								
}

//-------------------------------------------------------------------------
//	Функция чтения байта из шины.
//	Возвращает прочитанный байт
//
//-------------------------------------------------------------------------

BYTE owire_read()					
{
	cli();									
	BYTE byte = 0, i;					
	for (i=0; i<8; i++)						
	{
		byte >>= 1;							
		if (owire_read_bit())				
		byte |= 0x80;						
	}
	sei();									
	return byte;							
}



#endif /* W_H_ */