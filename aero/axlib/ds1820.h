
//-----------------------------------------------<                     axlib v1.1                      >----------------------------------------------------
//-----------------------------------------------< Библиотека для работы с датчиком температуры DS1820 >----------------------------------------------------
//-----------------------------------------------<      Кузнецов Алексей 2015 http://www.avrki.ru      >----------------------------------------------------

#ifndef DS1820_H_
#define DS1820_H_

#if !defined(W_H_)
#error "You must included (#include <axlib/1w.h>) befor use (#include <axlib/ds1820.h>)."
#endif

//-------------------------------------------------------------------------
//						Объявление служебных псевдонимов
//-------------------------------------------------------------------------

#define PLUS		0
#define MINUS		1
#define RESOL_9		0x1F
#define RESOL_10	0x3F
#define RESOL_11	0x5F
#define RESOL_12	0x7F

//-------------------------------------------------------------------------
//						Подключение библиотек
//-------------------------------------------------------------------------

#include <axlib/type_var.h>

//-------------------------------------------------------------------------
//						Объявление глобальных переменных
//-------------------------------------------------------------------------

volatile BYTE ZNAK = PLUS; 

//-------------------------------------------------------------------------
//							Объявление функций
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//	Функция получения ROM кода от датчика.
//	При условии наличия только одного датчика на линии.
//  ROM код записывается в передаваемый массив. Длина массива 8 байт.
//
//  Функция возвращает 0 если на линии есть датчик, 1 если линия пустая.
//
//	Принимаемый аргумент:
//
//		BYTE *str - Указатель на первый элемент массива
//-------------------------------------------------------------------------

BYTE ds1820_rom_code(BYTE *str)
{
	BYTE i = 0;
	BYTE exist= owire_init();
	owire_write(0x33);
	
	while(i < 8)
	{
		*str = owire_read();
		str++;
		i++;
	}
	return exist;
}

//-------------------------------------------------------------------------
//	Функция задания разрешения измерения.
//	При условии наличия только одного датчика на линии.
//
// Передоваемый аргумент:	RESOL_9
//							RESOL_10
//							RESOL_11
//							RESOL_12
//
//-------------------------------------------------------------------------
void ds18b20_resol(BYTE resol)
{
	owire_init();
	owire_write(0xCC);
	owire_write(0x4E);	
	owire_write(0x7D);
	owire_write(0xC9);
	owire_write(resol);
	
	_delay_ms(10);
	
	owire_init();
	owire_write(0xCC);
	owire_write(0x48);
}
//-------------------------------------------------------------------------
//	Функция получения температуры от датчика.
//	При условии наличия только одного датчика на линии.
//
//-------------------------------------------------------------------------

WORD ds1820_all(void)
{
	BYTE temp[2];
	WORD temper = 0x00;
	BYTE exist = owire_init();
	owire_write(0xCC);
	owire_write(0x44);
	
	_delay_ms(10);

	owire_init();
	owire_write(0xCC);
	owire_write(0xBE);
	
	temp[0] = owire_read();
	temp[1] = owire_read();
	
	if(temp[1] & 0x80)
		{
			temp[0] = (~temp[0])+1;
			temp[1] = ~temp[1];
			ZNAK = MINUS;
		}
	else
		{
			ZNAK = PLUS;
		}
	
	owire_init();
	
	temper = (((WORD)temp[1] << 8) | (WORD)(temp[0] * 5));
	if(exist) return 	temper;
	else return 0x8000;
}

//-------------------------------------------------------------------------
//	Функция получения температуры от датчика по его ROM коду.
//	Может работать при наличии нескольких датчиков на линии.
//
//  Передаваемые аргументы
//
//		BYTE *rom - Указатель на 8-и байтный массив с ROM кодом
//
//-------------------------------------------------------------------------

WORD ds1820_read_t(BYTE *rom)
{
	BYTE i = 0;
	BYTE temp[2];
	WORD temper = 0x00;
	BYTE rm = 0;
	
	BYTE exist = owire_init();
	owire_write(0xCC);
	owire_write(0x44);
	
	_delay_ms(10);

	i = 0;
	
	owire_init();
	owire_write(0x55);
	
	rm = *rom;
	
	while(i < 8)
		{
			owire_write(*rom);
			rom++;
			i++;
		}
	owire_write(0xBE);

	temp[0] = owire_read();
	temp[1] = owire_read();
	
	if(temp[1] & 0x80)
		{
			temp[0] = ~temp[0] + 1;
			temp[1] = ~temp[1];
			ZNAK = MINUS;
		}
	else
		{
			ZNAK = PLUS;
		}
	
	if(rm == 0x10)
		{
			temper = (temp[1] << 8) | (temp[0] * 5);
		}
	else
		{
			temper = ((temp[1] << 5) | (temp[0] >> 3)) * 5;
			//temper = temp[0];
		}
	
	owire_init();
	
if(exist) return 	temper;
	else return 0x8000;
}

#endif /* DS1820_H_ */