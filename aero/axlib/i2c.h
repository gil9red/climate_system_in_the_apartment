

//-------------------------------------------------<                   axlib v1.1                    >----------------------------------------------------
//-------------------------------------------------<        Библиотека для работы с шиной I2C        >----------------------------------------------------
//-------------------------------------------------<    Кузнецов Алексей 2015 http://www.avrki.ru    >----------------------------------------------------

#ifndef I2C_H_
#define I2C_H_

#if !defined(MAIN_INIT_H_)
#error "You must included (#include \"main_init.h\") befor use (#include <axlib/i2c.h>)."
#endif

//-------------------------------------------------------------------------
//						Объявление служебных псевдонимов
//-------------------------------------------------------------------------

#define ACK  0		// Ответ удачный
#define NACK 1		// Ответ не удачный


/*
#ifdef SSD1306_DELAY()
	#define I2C_DELAY()	_delay_us(1);	// Общая пауза на шине
#else
	#define I2C_DELAY()	_delay_us(10);	// Общая пауза на шине
#endif
*/

double  i2c_speed=1;// Общая пауза на шине, мкс. Если шина глючит, увеличивать.
#define I2C_DELAY() _delay_us(i2c_speed)		// Общая пауза на шине


#define ONE_SCL()	{ I2C_DDR &= ~(1 << SCL); I2C_PORT |= (1 << SCL); }  // Установка единицы на линии SCL
#define NULL_SCL()	{ I2C_DDR |= (1 << SCL);  I2C_PORT &= ~(1 << SCL); } // Установка нуля на линии SCL
#define ONE_SDA()	{ I2C_DDR &= ~(1 << SDA); I2C_PORT |= (1 << SDA); }  // Установка единицы на линии SDA
#define NULL_SDA()	{ I2C_DDR |= (1 << SDA);  I2C_PORT &= ~(1 << SDA); } // Установка нуля на линии SDA
	
#define OK				0	// Линия в норме
#define SCL_FAIL		1	// Ошибка линии SCL
#define SDA_FAIL		2	// Ошибка линии SDA
#define SDA_SCL_FAIL	3	// Ошибка линий SCL и SDA

#define WR		0   // Бит на запись
#define RD		1	// Бит на чтение
#define NO		2	// Бит не требуется

//-------------------------------------------------------------------------
//							Подключаемые библиотеки
//-------------------------------------------------------------------------

#include <axlib/type_var.h>

//-------------------------------------------------------------------------
//							Объявление функций
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//	Функция условия СТОП.
//
//	Возвращает OK 
//
//-------------------------------------------------------------------------

BYTE i2c_stop(void)
{
	BYTE error = OK;
	
	NULL_SCL();
	I2C_DELAY();
	NULL_SDA();
	I2C_DELAY();
	
	ONE_SCL();
	I2C_DELAY();
	ONE_SDA();
	I2C_DELAY();
	
	if((I2C_PIN & (1 << SDA)) == 0) error = SDA_FAIL;
	if((I2C_PIN & (1 << SCL)) == 0) error += SCL_FAIL;
	I2C_DELAY();
	I2C_DELAY();
	I2C_DELAY();
	I2C_DELAY();
	
	return error;
}

//-------------------------------------------------------------------------
//	Функция условия СТАРТ.
//
//-------------------------------------------------------------------------

void i2c_start(void)
{
	NULL_SDA();
	I2C_DELAY();
	NULL_SCL();
	I2C_DELAY();
}

//-------------------------------------------------------------------------
//	Функция условия ПОВСТАРТ.
//
//-------------------------------------------------------------------------

void i2c_restart(void)
{
	ONE_SDA();
	I2C_DELAY();
	ONE_SCL();
	I2C_DELAY();
	
	NULL_SDA();
	I2C_DELAY();
	NULL_SCL();
	I2C_DELAY();
}

//-------------------------------------------------------------------------
//	Функция инициализации шины.
//
//-------------------------------------------------------------------------

void i2c_init(void)
{
	ONE_SDA();
	ONE_SCL();
	
	i2c_stop();
}

//-------------------------------------------------------------------------
//	Функция передачи байта в шину.
//
//	Принимамые аргументы:
//
//		BYTE data - байт для передачи в шину
//
//  Возвращаемое значение:
//
//		Ответ от ведомого устройства ACK принято, NACK ошибка.
//-------------------------------------------------------------------------

BYTE i2c_send_byte(BYTE data)
{
	BYTE i;
	BYTE ask = ACK;
	
	for(i = 0; i < 8; i++)
	{
		if((data & 0x80) == 0)
		{
			NULL_SDA();
		}
		else
		{
			ONE_SDA();
		}
		I2C_DELAY();
		ONE_SCL();
		I2C_DELAY();
		NULL_SCL();
		
		data = (data << 1);
	}
	
	ONE_SDA();
	I2C_DELAY();
	ONE_SCL();
	I2C_DELAY();
	
	if((I2C_PIN & (1 << SDA)) == (1 << SDA))
	{
		ask = NACK;
	}
	else
	{
		ask = ACK;
	}
	
	NULL_SCL();
	
	return ask;
}

//-------------------------------------------------------------------------
//	Функция чтения байта из шины.
//
//	Передаваемый аргумент функции
//
//		BYTE ask - Чем ответит функция после получения байта ACK или NACK
//
//  Возвращаемое значение:
//
//		Полученный байт.
//-------------------------------------------------------------------------

BYTE i2c_read_byte(BYTE ask)
{
	BYTE byte = 0;
	BYTE i;
	
	ONE_SDA();
	
	for(i = 0; i < 8; i++)
	{
		byte = (byte << 1);
		ONE_SCL();
		I2C_DELAY();
		if((I2C_PIN & (1 << SDA)) == (1 << SDA)) byte |= 0x01;
		NULL_SCL();
		I2C_DELAY();
	}
	
	if(ask == ACK)
	{
		NULL_SDA();
	}
	else
	{
		ONE_SDA();
	}
	I2C_DELAY();
	ONE_SCL();
	I2C_DELAY();
	NULL_SCL();
	I2C_DELAY();
	ONE_SDA();
	
	return byte;
}

#endif /* I2C_H_ */