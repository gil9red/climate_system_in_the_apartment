
//-------------------------------------------------<                axlib v1.1                 >----------------------------------------------------
//-------------------------------------------------<     Библиотека для работы с таймерами     >----------------------------------------------------
//-------------------------------------------------< Кузнецов Алексей 2015 http://www.avrki.ru >----------------------------------------------------


#ifndef LED_7_H_
#define LED_7_H_

#if !defined(MAIN_INIT_H_)
#error "You must included (#include \"main_init.h\") befor use (#include <axlib/led_7.h>)."
#endif

//-------------------------------------------------------------------------
//							Подключаемые библиотеки
//-------------------------------------------------------------------------

#include <avr/io.h>
#include <axlib/type_var.h>

//-------------------------------------------------------------------------
//						Объявление служебных псевдонимов
//-------------------------------------------------------------------------

#define LED_MINUS	0x0B
#define LED_PLUS	0x0A

//-------------------------------------------------------------------------
//						Объявление глобальных масивов
//-------------------------------------------------------------------------

// Коды чисел и знаков

BYTE ch[] = {
	0xFC,	// 0		(00)
	0x60,	// 1		(01)
	0xDA,	// 2		(02)
	0xF2,	// 3		(03)
	0x66,	// 4		(04)
	0xB6,	// 5		(05)
	0xBE,	// 6		(06)
	0xE0,	// 7		(07)
	0xFE,	// 8		(08)
	0xF6,	// 9		(09)
	0x00,	// Пусто	(10)
	0x02,	// -		(11)
	0xEE,	// A		(12)
	0x6E,	// H		(13)
	0x9E,	// E		(14)
	0x7C,	// U		(15)
	0x9C,	// C		(16)
	0x1A,	// c		(17)
	0x0A,	// r		(18)
	0x3E,	// b		(19)
	0x3D,	// d		(20)
	0x38,	// u		(21)
	0xC6	// Градус	(22)
};

//-------------------------------------------------------------------------
//							Инициализация переменных
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//			Функция инициализации LED Дисплея
//-------------------------------------------------------------------------

void led_7_init(void)
{
	DDR_LED_DIG	|= ((1<< LED_DIG_1) | (1<< LED_DIG_2) | (1<< LED_DIG_3) | (1<< LED_DIG_4));
	DDR_LED_DATA |= ((1<< LED_DATA) | (1<< LED_SCK) | (1<< LED_SHIFT) | (1<< LED_RESET));
}

//-------------------------------------------------------------------------
//			Функция сброса регистра
//-------------------------------------------------------------------------

void led_7_reset(void)
{
	PORT_LED_DATA &= ~(1 << LED_RESET);
	PORT_LED_DATA |= (1 << LED_SHIFT);
	PORT_LED_DATA &= ~(1 << LED_SHIFT);
	PORT_LED_DATA |= (1 << LED_RESET);	
}

//-------------------------------------------------------------------------
//			Функция выбора разряда
//-------------------------------------------------------------------------

void led_7_raz_set(BYTE raz)
{
	PORT_LED_DIG |= (1 << raz);
}

//-------------------------------------------------------------------------
//			Функция сброса разряда
//-------------------------------------------------------------------------

void led_7_raz_reset(BYTE raz)
{
	PORT_LED_DIG &= ~(1 << raz);
}

//-------------------------------------------------------------------------
//			Функция вывода знака в текущий разряд
//-------------------------------------------------------------------------

void led_7_char_out(BYTE data)
{
	BYTE count = 0;
	BYTE temp = 0;
	
	PORT_LED_DATA &= ~(1 << LED_SCK);
	PORT_LED_DATA &= ~(1 << LED_SHIFT);
	PORT_LED_DATA |= (1 << LED_RESET);
	
	for(count=0; count<8; count++)
		{
			temp = ((ch[data] >> count) & 0x01);
		
			if(temp == 0x01)
				{
					PORT_LED_DATA |= (1 << LED_DATA);
				}
			else
				{
					PORT_LED_DATA &= ~(1 << LED_DATA);
				}
	
			PORT_LED_DATA |= (1 << LED_SCK);
			PORT_LED_DATA &= ~(1 << LED_SCK);
		}
	
	PORT_LED_DATA |= (1 << LED_SHIFT);
	PORT_LED_DATA &= ~(1 << LED_SHIFT);
}

//-------------------------------------------------------------------------
//			Функция цикла разрядов
//-------------------------------------------------------------------------

void led_7_cicle(BYTE *data)
{
	led_7_raz_reset(LED_DIG_4);
	led_7_raz_set(LED_DIG_1);
	
	if(*data == LED_PLUS)
		{
			_delay_ms(1);
			led_7_reset();
		}
	else
		{
			led_7_char_out(*data);
			_delay_ms(1);
			led_7_reset();
		}
	data++;
	
	led_7_raz_reset(LED_DIG_1);
	led_7_raz_set(LED_DIG_2);
	
	led_7_char_out(*data);
	_delay_ms(1);
	led_7_reset();
	data++;
	
	led_7_raz_reset(LED_DIG_2);
	led_7_raz_set(LED_DIG_3);
	
	led_7_char_out(*data);
	_delay_ms(1);
	led_7_reset();
	data++;
	
	led_7_raz_reset(LED_DIG_3);
	led_7_raz_set(LED_DIG_4);
	
	led_7_char_out(*data);
	_delay_ms(1);
	led_7_reset();
}

//-------------------------------------------------------------------------
//			Функция вывода данных
//-------------------------------------------------------------------------

void led_7_temperatura(BYTE temper)
{
	BYTE dig[4] = {0};
		
	dig[3] = 22;
		
	if(temper & 0x80)
		{
			dig[0] = LED_MINUS;
			temper &= ~(1 << 7);
		}
	else
		{
			dig[0] = LED_PLUS;
		}
	
	if(temper <= 9)
		{
			dig[1] = temper;
			dig[2] = 22;
			dig[3] = 10;
			
		}
	else
		{
			while(temper >= 10)
			{
				temper = temper - 10;
				dig[1]++;
			}
			dig[2] = temper;
		}
	
	led_7_cicle(dig);
}

//-------------------------------------------------------------------------
//			Функция вывода Err
//-------------------------------------------------------------------------

void led_7_err(void)
{
	BYTE dig[4] = {10, 14, 18, 18};
	led_7_cicle(dig);	
}

#endif /* LED_7_H_ */